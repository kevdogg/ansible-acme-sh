---
# ============================================================================
# acme-domain-workflow.yml
# ----------------------------------------------------------------------------
# Purpose:
#   Handles per-domain certificate issuance, renewal, and deployment logic.
#   Covers the full lifecycle of ACME-managed certificates, including:
#     â€¢ Detecting existing RSA/ECC certificates and renewal state
#     â€¢ Issuing or force-renewing certificates as required
#     â€¢ Generating PKCS#12 bundles and deploying local copies
#     â€¢ Recording post-deployment state for reporting and comparison
#     â€¢ Appending results to the global scoreboard for summary output
#
# Scope:
#   This file runs once per domain entry (looped in host_vars).
#   Complementary to:
#     - acme-install-acme-sh.yml (per-host setup)
#     - acme-domain-remove.yml (cleanup/removal)
#
# Notes:
#   - Fully idempotent; re-running will only update changed certificates.
#   - Uses resolve-paths.yml to determine RSA/ECC-specific working paths.
#   - Integration point for debug-acme-scoreboard.yml in verbose mode.
#
# Version: 2025.11.07 / compatible with acme.sh â‰¥ 3.0.8
# Maintainer: KevDog
# Tags: [acme, letsencrypt, domain, renewal, deployment, workflow]
# ============================================================================



# acme_domain_workflow.yml
# Handle issuance or renewal for a single domain entry in acme_sh_domains
# ======================================================================
# ACME.SH PATH RESOLUTION (change ~/.acme.sh to {{ become_user }}_home_dir/.acme.sh)
# ======================================================================
- name: Resolve acme.sh paths
  ansible.builtin.include_tasks:
    file: acme-resolve-paths.yml
    apply:
      tags: [always]
  tags: [always]
# ======================================================================
# PATH RESOLUTION (RSA/ECC)
# ======================================================================
- name: Resolve relevant paths for this domain
  ansible.builtin.include_tasks:
    file: acme-resolve-rsa-vs-ecc-paths.yml
    apply:
      tags: [always]
    tags: [always]

# ======================================================================
# PRE-DEPLOY SNAPSHOT
# ======================================================================
- name: Set pre-deploy live certificate reference
  ansible.builtin.stat:
    path: "{{ acme_sh_cert_path_resolved }}/fullchain.cer"
  register: live_cert_before
  failed_when: false
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"

- name: Record baseline certificate mtime
  ansible.builtin.set_fact:
    acme_live_cert_path_before: "{{ live_cert_before.stat.path | default(acme_sh_cert_path_resolved ~ '/fullchain.cer') }}"
    acme_live_cert_mtime_before: "{{ live_cert_before.stat.mtime | default(0) }}"
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"

# ======================================================================
# ISSUE / RENEW
# ======================================================================
- name: Force renew acme.sh certificate(s) if force option specified
  vars:
    acme_exe: "{{ acme_sh_bin_resolved | default(acme_sh_bin | default(acme_sh_default_bin, true)) }}"
  ansible.builtin.shell: >-
    {{
      acme_exe ~ ' --renew -d ' ~ (item.domains | first) ~ ' --force' ~
      ( ' --debug' if item.debug | default(acme_sh_default_debug | default(false)) | bool else '' ) ~
      ( ' ' ~ (
          item.acme_sh_extra_flags_renew
          | default(acme_sh_default_extra_flags_renew
          | default(acme_sh_default_extra_flags, true), true)
          | default('', true)
        )
      )
    }}
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "{{ bash_executable_path }}"
  register: renew_result
  changed_when: "{{ (renew_result.rc | default(1) | int) == 0 }}"
  failed_when: >-
    {{
      (renew_result.rc | default(1) | int) not in [0, 2]
      and ("Reload error for" not in (renew_result.stderr | default('')))
    }}
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"
  when:
    - item.force_renew | default(false) | bool
    - not item.custom_command | default(false) | bool
  tags: [summary]

- name: Record force renew outcome in scoreboard
  ansible.builtin.set_fact:
    acme_summary: >-
      {{
        acme_summary | combine({
          'renewed': (
            (acme_summary.renewed | default([])) + [{
              'domain': (item.domains | first),
              'forced': true
            }]
          ) if ((renew_result.rc | int) == 0) else (acme_summary.renewed | default([])),

          'skipped': (
            (acme_summary.skipped | default([])) + [{
              'domain': (item.domains | first),
              'status': 'already_valid',
              'message': 'Force renew requested but acme.sh skipped (already valid)',
              'forced': true
            }]
          ) if ((renew_result.rc | int) == 2) else (acme_summary.skipped | default([])),

          'failed': (
            (acme_summary.failed | default([])) + [{
              'domain': (item.domains | first),
              'message': 'Force renew failed',
              'rc': (renew_result.rc | default('')),
              'stdout': (renew_result.stdout | default('')),
              'stderr': (renew_result.stderr | default('')),
              'forced': true
            }]
          ) if ((renew_result.rc | default(1) | int) not in [0,2]) else (acme_summary.failed | default([]))
        }, recursive=True)
      }}
  changed_when: true
  when:
    - item.force_renew | default(false) | bool
    - renew_result is defined

- name: Issue acme.sh certificate(s) (this will sleep for dns_sleep seconds)
  vars:
    acme_exe: "{{ acme_sh_bin_resolved | default(acme_sh_bin | default(acme_sh_default_bin, true)) }}"
  ansible.builtin.shell: >-
    {{
      acme_exe ~ ' --issue -d ' ~ (item.domains | join(' -d ')) ~
      ' --dns ' ~ (item.dns_provider | default(acme_sh_default_dns_provider | default('dns_cf'))) ~
      ' --dnssleep ' ~ (item.dns_sleep | default(acme_sh_default_dns_sleep | default('30')) | string) ~
      ( ' --force' if (item.force_issue | default(acme_sh_default_force_issue | default(false)) | bool)
                     or (item.force_renew | default(acme_sh_default_force_renew | default(false)) | bool)
        else '' ) ~
      ( ' --staging' if item.staging | default(acme_sh_default_staging | default(false)) | bool else '' ) ~
      ( ' --debug' if item.debug | default(acme_sh_default_debug | default(false)) | bool else '' ) ~
      ( ' ' ~ (item.acme_sh_extra_flags_issue | default(acme_sh_default_extra_flags_issue | default('--keylength ec-384 --ecc'))) )
    }}
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "{{ bash_executable_path }}"
  environment: "{{ item.dns_provider_api_keys | default(acme_sh_default_dns_provider_api_keys | default({})) }}"
  register: issue_result
  changed_when: >-
    {{
      (issue_result.rc | default(1) | int) == 0
      and (
        "Cert success" in (issue_result.stdout | default('')) or
        "Renew" in (issue_result.stdout | default('')) or
        "Create new certificate" in (issue_result.stdout | default(''))
      )
    }}
  failed_when: "{{ (issue_result.rc | default(1) | int) not in [0, 2] }}"
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"
  when:
    - not item.force_renew | default(false) | bool
    - not item.custom_command | default(false) | bool

- name: Mark certificate as already valid (no renewal needed) if certificate not due for renewal
  ansible.builtin.set_fact:
    acme_summary: >-
      {{
        acme_summary | combine({
          'skipped': (acme_summary.skipped | default([])) + [{
            'domain': (item.domains | first),
            'status': 'already_valid',
            'message': 'acme.sh reports next renewal time in future'
          }]
        }, recursive=True)
      }}
  when:
    - not item.force_renew | default(false) | bool
    - not item.custom_command | default(false) | bool
    - (issue_result.rc | int) == 2
  changed_when: true
  tags: [summary]

# ======================================================================
# POST-ISSUE SNAPSHOT
# ============================================i==========================
- name: Check updated certificate (after issue)
  ansible.builtin.stat:
    path: "{{ acme_sh_cert_path_resolved }}/fullchain.cer"
  register: live_cert_after
  failed_when: false
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"

- name: Capture certificate mtime after
  ansible.builtin.set_fact:
    acme_live_cert_path_after: "{{ live_cert_after.stat.path | default(acme_sh_cert_path_resolved ~ '/fullchain.cer') }}"
    acme_live_cert_mtime_after: "{{ live_cert_after.stat.mtime | default(0) }}"
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"

- name: Determine if certificate changed (mtime after > before)
  ansible.builtin.set_fact:
    acme_cert_updated: "{{ (acme_live_cert_mtime_after | int) > (acme_live_cert_mtime_before | default(0) | int) }}"
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"


# ======================================================================
# PKCS#12 CREATION
# ======================================================================
- name: Generate PKCS#12 (pfx)
  vars:
    acme_exe: "{{ acme_sh_bin | default(acme_sh_default_bin, true) }}"
    pkcs_pass: "{{ item.acme_sh_pkcs12_password | default(acme_sh_default_pkcs12_password) | default('pass') }}"
  ansible.builtin.shell: >-
    {{
      acme_exe ~ ' --toPkcs -d ' ~ item.domains[0] ~ ' --password ' ~ pkcs_pass ~
      ( ' --ecc' if (item.acme_sh_extra_flags | default(acme_sh_default_extra_flags) | default(''))
                  | regex_search('(^|\\s)--ecc(\\s|$)') else '' )
    }}
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "{{ bash_executable_path }}"
  register: pkcs_result
  failed_when: pkcs_result.rc != 0
  when:
    - acme_cert_updated | default(false) | bool
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"

# ======================================================================
# DEPLOY CERTIFICATE
# ======================================================================

- name: Check localcopy deploy hook is present
  ansible.builtin.stat:
    path: "{{ acme_sh_directory_resolved }}/deploy/localcopy.sh"
  register: _localcopy_hook
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"

- name: Ensure localcopy destination directory exists
  ansible.builtin.file:
    path: "{{ (acme_sh_copy_certs_to_path | default(acme_sh_default_copy_certs_to_path, true)) }}/{{ item.domains | first }}"
    state: directory
    mode: "0755"
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"
  when:
    - _localcopy_hook.stat.exists
    - acme_cert_updated | default(false) | bool

- name: Deploy acme.sh certificates
  vars:
    acme_exe: "{{ acme_sh_bin | default(acme_sh_default_bin, true) }}"
  ansible.builtin.shell: >-
    {{
      acme_exe ~ ' --deploy -d ' ~ (item.domains | first) ~ ' --deploy-hook localcopy' ~
      ( ' --ecc' if (item.acme_sh_extra_flags | default(acme_sh_default_extra_flags) | default(''))
                  | regex_search('(^|\\s)--ecc(\\s|$)') else '' )
    }}
  environment:
    DEPLOY_LOCALCOPY_CERTKEY: "{{ (acme_sh_copy_certs_to_path | default(acme_sh_default_copy_certs_to_path, true)) }}/{{ item.domains | first }}/key.pem"
    DEPLOY_LOCALCOPY_CERTIFICATE: "{{ (acme_sh_copy_certs_to_path | default(acme_sh_default_copy_certs_to_path, true)) }}/{{ item.domains | first }}/cert.pem"
    DEPLOY_LOCALCOPY_FULLCHAIN: "{{ (acme_sh_copy_certs_to_path | default(acme_sh_default_copy_certs_to_path, true)) }}/{{ item.domains | first }}/fullchain.pem"
    DEPLOY_LOCALCOPY_CA: "{{ (acme_sh_copy_certs_to_path | default(acme_sh_default_copy_certs_to_path, true)) }}/{{ item.domains | first }}/ca.pem"
    DEPLOY_LOCALCOPY_PFX: "{{ (acme_sh_copy_certs_to_path | default(acme_sh_default_copy_certs_to_path, true)) }}/{{ item.domains | first }}/pkcs12.pfx"
    DEPLOY_LOCALCOPY_RELOADCMD: "{{ item.install_cert_reloadcmd | default(acme_sh_default_install_cert_reloadcmd, true) }}"  
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "{{ bash_executable_path | default('/bin/bash') }}"
  register: deploy_result
  failed_when: deploy_result.rc != 0
  become: true
  become_user: "{{ acme_sh_become_user | default(omit) }}"
  when:
    - _localcopy_hook.stat.exists
    - (pkcs_result.rc | default(1)) == 0
    - acme_cert_updated | default(false) | bool
    

# ======================================================================
# POST-DEPLOY VALIDATION
# ======================================================================
- name: Record certificate validity after deploy
  ansible.builtin.include_tasks:
    file: acme-parse-list.yml
    apply:
      tags: [always]
  vars:
    acme_list_fail_on_error: false   # donâ€™t fail entire domain if list hiccups
    acme_list_compute_status: false  # you only need days_remaining
  tags: [workflow]

- name: Save post-deploy certificate info
  ansible.builtin.set_fact:
    acme_post_cert_info: "{{ acme_cert_info | default({}) }}"

# ======================================================================
# SCOREBOARD
# ======================================================================
- name: Set per-domain result
  ansible.builtin.set_fact:
    acme_domain_status: >-
      {{
        (
          'failed' if (
            (issue_result.rc | default(0)) != 0
            or (renew_result.rc | default(0)) != 0
            or (pkcs_result.rc | default(0)) != 0
            or (deploy_result.rc | default(0)) != 0
          ) else (
            'renewed' if acme_cert_updated
            else 'skipped' if ('Skip' in (issue_result.stdout | default('')))
            else 'installed'
          )
        )
      }}
    reason_failed: >-
      {{
        'issue'  if (issue_result.rc | default(1)) != 0 else
        'renew'  if (renew_result.rc | default(1)) != 0 else
        'pkcs12' if (pkcs_result.rc | default(1)) != 0 else
        'deploy' if (deploy_result.rc | default(1)) != 0 else
        omit
      }}
    acme_domain_result:
      domain: "{{ item.domains[0] }}"
      domains: "{{ item.domains }}"
      status: "{{ acme_domain_status }}"
      reason_failed: "{{ reason_failed | default(omit) }}"
      rc_issue: "{{ issue_result.rc | default(omit) }}"
      rc_renew: "{{ renew_result.rc | default(omit) }}"
      rc_pkcs: "{{ pkcs_result.rc | default(omit) }}"
      rc_deploy: "{{ deploy_result.rc | default(omit) }}"
      stdout_issue: "{{ issue_result.stdout | default('') }}"
      stdout_renew: "{{ renew_result.stdout | default('') }}"
      live_cert_path: "{{ acme_live_cert_path_after }}"
      force_renew: "{{ item.force_renew | default(false) }}"
      new_days_remaining: "{{ acme_post_cert_info[item.domains[0]].days_remaining | default(omit) }}"
  when: issue_result is defined or renew_result is defined

# ======================================================================
# PLAN vs ACTUAL COMPARISON
# ======================================================================
- name: Compare planned vs actual outcome (per domain)
  ansible.builtin.set_fact:
    _planned_action: >-
      {{
        acme_plan_summary.domain_actions[item.domains[0]].action
        if (
          acme_plan_summary is defined and
          acme_plan_summary.domain_actions is defined and
          acme_plan_summary.domain_actions[item.domains[0]] is defined
        )
        else 'UNKNOWN'
      }}
    _actual_action: >-
      {{
        'INSTALL' if acme_domain_status in ['installed','skipped'] else
        'FORCE_RENEW' if acme_domain_status == 'renewed' else
        'FAILED' if acme_domain_status == 'failed' else
        (acme_domain_status | upper)
      }}
    _plan_match: "{{ _planned_action == _actual_action }}"
  when:
    - acme_domain_status is defined
  tags: debug

- name: Show per-domain planned vs actual summary
  ansible.builtin.debug:
    msg: >-
      {{
        (
          'ğŸ“‹ ' ~ item.domains[0] ~
          ': planned=' ~ _planned_action ~
          ', actual=' ~ _actual_action ~
          (
            ' âœ… MATCH'
            if _plan_match
            else ' âŒ MISMATCH'
          )
        )
      }}
  when:
    - acme_domain_status is defined
    - acme_plan_summary is defined
  tags: debug

# ======================================================================
# APPEND TO GLOBAL SCOREBOARD
# ======================================================================
- name: Append result to scoreboard buckets
  ansible.builtin.set_fact:
    acme_summary: >-
      {{
        acme_summary
        | combine({
            'installed': (acme_summary.installed + [acme_domain_result])
                          if acme_domain_status == 'installed' else acme_summary.installed,
            'renewed':   (acme_summary.renewed   + [acme_domain_result])
                          if acme_domain_status == 'renewed' else acme_summary.renewed,
            'skipped':   (acme_summary.skipped   + [acme_domain_result])
                          if acme_domain_status == 'skipped' else acme_summary.skipped,
            'failed':    (acme_summary.failed    + [acme_domain_result])
                          if acme_domain_status == 'failed' else acme_summary.failed
          }, recursive=True)
      }}
  when: acme_domain_status is defined

# ======================================================================
# OPTIONAL DEBUG SNAPSHOT
# ======================================================================
- name: Snapshot current scoreboard (verbose mode only)
  ansible.builtin.include_tasks:
    file: debug-acme-scoreboard.yml
    apply:
      tags: [always]
  when: ansible_verbosity | int >= 2
  tags: debug

