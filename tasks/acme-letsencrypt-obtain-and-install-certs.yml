---
- name: Run custom acme.sh command
  ansible.builtin.command: ./acme.sh {{ item.custom_command }}
  args:
    chdir: "{{ acme_sh_default_directory }}"
  environment: "{{ item.dns_provider_api_keys | default(acme_sh_default_dns_provider_api_keys) }}"
  loop: "{{ acme_sh_domains }}"
  when:
    - acme_sh_domains is defined and acme_sh_domains | length > 0
    - items.domains is defined and item.domains | length > 0
    - (item.dns_provider | default(acme_sh_default_dns_provider)) | length > 0
    - (item.dns_provider_api_keys | default(acme_sh_default_dns_provider_api_keys)) > length > 0
    - item.custom_command is defined and item.custom_command | length > 0
    - item.remove is undefined or not item.remove
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
  become_user: "{{ acme_sh_become_user }}"
  tags: custom_command

- name: Issue acme.sh certificate(s) (this will sleep for dns_sleep seconds)
  ansible.builtin.command: >-
    ./acme.sh --issue -d {{ item.domains | join(" -d ") }}
    {{ acme_sh_extra_flags_issue | default(acme_sh_default_extra_flags_issue) }}
    --dns {{ item.dns_provider | default(acme_sh_default_dns_provider) }}
    --dnssleep {{ item.dns_sleep | default(acme_sh_default_dns_sleep) }}
    {{ "--domain-alias" if item.domain_alias | default(acme_sh_default_domain_alias|default("")) else ""}}
    {{ "--challenge-alias " + '"' + item.challenge_alias | default(acme_sh_default_challenge_aliass) + '"' if item.challenge_alias | default(acme_sh_default_challenge_aliass|default("")) else "" }}
    {{ "--force" if item.force_issue | default(acme_sh_default_force_issue) else "" }}
    {{ "--staging" if item.staging | default(acme_sh_default_staging) else "" }}
    {{ "--debug" if item.debug | default(acme_sh_default_debug) else "" }}
    {{ "--pre-hook " + '"' + item.issue_pre_hook | default(acme_sh_default_issue_pre_hook) + '"' if item.issue_pre_hook | default(acme_sh_default_issue_pre_hook) else "" }}
    {{ "--post-hook " + '"' + item.issue_post_hook | default(acme_sh_default_issue_post_hook) + '"' if item.issue_post_hook | default(acme_sh_default_issue_post_hook) else "" }}
    {{ "--renew-hook " + '"' + item.issue_renew_hook | default(acme_sh_default_issue_renew_hook) + '"' if item.issue_renew_hook | default(acme_sh_default_issue_renew_hook) else "" }}
    {{ item.extra_flags_issue | default(acme_sh_default_extra_flags_issue) }}
  args:
    chdir: "{{ acme_sh_default_directory }}"
  environment: "{{ item.dns_provider_api_keys | default(acme_sh_default_dns_provider_api_keys) }}"
  loop: "{{ acme_sh_domains }}"
  when:
    - acme_sh_domains and item.domains is defined and item.domains
    - item.dns_provider | default(acme_sh_default_dns_provider)
    - item.dns_provider_api_keys | default(acme_sh_default_dns_provider_api_keys)
    - item.force_renew is undefined or not item.force_renew
    - item.custom_command is undefined or not item.custom_command
    - item.remove is undefined or not item.remove
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
  become_user: "{{ acme_sh_become_user }}"
  register: issue_result
  changed_when: issue_result.rc == 0 and "Cert success" in issue_result.stdout
  failed_when: issue_result.rc != 0 and "Domains not changed" not in issue_result.stdout
  tags: install_domain

#- name: Debug Return code for issue command
#  ansible.builtin.debug: var=issue_result
#  become_user: "{{ acme_sh_become_user }}"

#- name: Looking for return codes
#  ansible.builtin.debug:
#    msg:
#      - "Return code {{ item.rc }}"
#  loop: "{{ issue_result.results }}"

- name: Force renew acme.sh certificate(s)
  ansible.builtin.command: >-
    ./acme.sh --renew -d {{ item.domains | first }} --force
    {{ "--debug" if item.debug | default(acme_sh_default_debug) else "" }}
    {{ item.extra_flags_renew | default(acme_sh_default_extra_flags_renew) }}
  args:
    chdir: "{{ acme_sh_default_directory }}"
  loop: "{{ acme_sh_domains }}"
  when:
    - acme_sh_domains and item.domains is defined and item.domains
    - item.force_issue is undefined or not item.force_issue
    - item.force_renew is defined and item.force_renew
    - item.remove is undefined or not item.remove
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
  become_user: "{{ acme_sh_become_user }}"
  register: renew_result
  failed_when: renew_result.rc != 0 and "Reload error for" not in renew_result.stderr
  tags: force_renew_domain

- name: Create acme.sh install directory path(s) for domain(s) certificates
  ansible.builtin.file:
    path: "{{ acme_sh_copy_certs_to_path }}/{{ item.domains | first }}"
    state: "directory"
    group: "{{ acme_sh_become_user }}"
    owner: "{{ acme_sh_become_user }}"
    mode: "{{ acme_sh_install_directory_permissions | default(acme_sh_default_install_directory_permissions) }}"
  loop: "{{ acme_sh_domains }}"
  when:
    - acme_sh_domains and item.domains is defined and item.domains
    - item.custom_command is undefined or not item.custom_command
    - item.remove is undefined or not item.remove
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
  become_user: "{{ acme_sh_become_user }}"

#- name: Create pcks12 file using acme technique -- This function requires a password to be set
#  ansible.builtin.command: >-
#    ./acme.sh --to-pkcs12 --domain {{ item.domains | first }}
#    {{ "--password " + item.acme_sh_pkcs12_password | default(acme_sh_default_pkcs12_password) if item.acme_sh_pkcs12_password | (acme_sh_default_pkcs12_password is defined and acme_sh_default_pkcs12_password is not none and acme_sh_default_pkcs12_password | length) else "pass" }}
#  loop: "{{ acme_sh_domains }}"
#  when:
#    - (item.acme_sh_pkcs12_password is defined and item.acme_sh_pkcs12_password is not not and item.acme_sh_pkcs12_password | length) or (acme_sh_default_pkcs12_password is defined and acme_sh_default_pkcs12_password is not none and acme_sh_default_pkcs12_password | length)
#  become_user: "{{ acme_sh_become_user }}"
#  register: pkcs12_create_result
#
#- name: Install ReloadCmd Template to install pkcs12.file
#  ansible.builtin.template:
#    src: pkcs12.sh.j2
#    dest: "{{ acme
#    force: true
#    owner: root
#    group: root
#    mode: 0755
#  when:
#    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
#  become_user: "{{ acme_sh_become_user }}"


- name: Locate openssl executable
  ansible.builtin.command: which openssl
  become_user: "{{ acme_sh_become_user }}"
  ignore_errors: true
  register: which_openssl_result
  failed_when: which_openssl_result.rc != 0 and 'no openssl in' not in which_openssl_result.stderr
  changed_when: false # Discovery tasks should not report change
  when:
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false

- name: Set fact for openssl path with fallback
  ansible.builtin.set_fact:
    openssl_path: >-
      {{
        (which_openssl_result.rc == 0)
        | ternary(which_openssl_result.stdout | trim, '/usr/bin/openssl')
      }}
  when:
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false

- name: Determine bash executable path
  ansible.builtin.command: which bash
  register: bash_path_result
  # Use a simple failed_when to ensure 'bash' was found
  failed_when: bash_path_result.rc != 0
  changed_when: false
  when:
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false

- name: Set bash_executable_path fact with ternary fallback
  ansible.builtin.set_fact:
    bash_executable_path: >-
      {{ 
        bash_path_result.rc == 0 
        | ternary(bash_path_result.stdout | trim, '/usr/bin/bash') 
      }}
  when:
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false


  # Here is command structute I'm working with openssl pkcs12 --export -out /data/technitium/config/certs/ns1.gohilton.com/pkcs12pretest.pfx -inkey /etc/ssl/letsencrypt/ns1.gohilton.com/key.pem -in /etc/ssl/letsencrypt/ns1.gohilton.com/cert.pem -certfile /etc/ssl/letsencrypt/ns1.gohilton.com/fullchain.pem --passin pass: --passout pass:tech
- name: Add pkcs12_base_reloadcmd and combine commands into acme_reloadcmd (with all fallbacks)
  ansible.builtin.set_fact:
    acme_sh_domains: >-
      {{
        acme_sh_domains
        | map('combine', {
            # 1. Define pkcs12_base_reloadcmd
            'pkcs12_base_reloadcmd': (
                openssl_path
                ~ " pkcs12 --export"
                ~ " -out " ~ acme_sh_copy_certs_to_path ~ "/" ~ item.domains[0] ~ "/pkcs12.pfx"
                ~ " -inkey " ~ acme_sh_copy_certs_to_path ~ "/" ~ item.domains[0] ~ "/key.pem"
                ~ " -in " ~ acme_sh_copy_certs_to_path ~ "/" ~ item.domains[0] ~ "/fullchain.pem"
                ~ " --passin pass:"
                ~ " --passout pass:" 
                # ROBUST PASSWORD LOGIC: Fallback to acme_sh_default_pkcs12_password, then to empty string ('')
                ~ (item.acme_sh_pkcs12_password | default(acme_sh_default_pkcs12_password) | default(''))
            ),
            # 2. Define acme_reloadcmd
            'acme_reloadcmd': (
                item.pkcs12_base_reloadcmd
                ~ ' && ' 
                # ROBUST RELOAD CMD LOGIC: Fallback to acme_sh_default_install_cert_reloadcmd, then to 'true' (no-op)
                ~ (item.install_cert_reloadcmd | default(acme_sh_default_install_cert_reloadcmd) | default('true'))
            )
          })
        | list
      }}
  when:
    - acme_sh_domains is defined and acme_sh_domains | length > 0
    - item.custom_command is undefined or not item.custom_command
    - item.remove is undefined or not item.remove
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false

- name: Install acme.sh certificate(s)
  ansible.builtin.shell: >- 
    ./acme.sh --install-cert -d {{ item.domains | first }}
    --key-file {{ acme_sh_copy_certs_to_path }}/{{ item.domains | first }}/key.pem
    --fullchain-file {{ acme_sh_copy_certs_to_path }}/{{ item.domains | first }}/fullchain.pem
    --ca-file {{ acme_sh_copy_certs_to_path }}/{{ item.domains | first }}/ca.pem
    --cert-file {{ acme_sh_copy_certs_to_path }}/{{ item.domains | first }}/cert.pem
    
    --reloadcmd "{{ item.acme_reloadcmd }}"
    
    {{ ("--debug" if item.debug | default(acme_sh_default_debug) else "") }}
    {{ item.extra_flags_install_cert | default(acme_sh_default_extra_flags_install_cert, '') }}
  args:
    chdir: "{{ acme_sh_default_directory }}"
    executable: "{{ bash_executable_path }}" 
  loop: "{{ acme_sh_domains }}"
  loop_control:
    index_var: domains_index
    extended: true
  when:
    - acme_sh_domains and item.domains is defined and item.domains
    - item.custom_command is undefined or not item.custom_command
    - item.remove is undefined or not item.remove
    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
  become_user: "{{ acme_sh_become_user }}"
  register: install_cert_result
  changed_when: issue_result.results[domains_index].changed or renew_result.results[domains_index].changed
  failed_when: install_cert_result.rc != 0 and "Reload error for" not in install_cert_result.stderr

#- name: pkcs12_file_block
#  ansible.builtin.include_tasks:
#    file: acme-pkcs12-file.yml
#    apply:
#      tags: pkcs12
#  loop: "{{ acme_sh_domains }}"
#  when:
#    - acme_sh_domains and item.domains is defined and item.domains
#    - item.custom_command is undefined or not item.custom_command
#    - item.remove is undefined or not item.remove
#    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
#    - which_openssl_result.rc == 0
#  tags:
#    - pkcs12

#- name:  Determine if there exists a pkcs12.pfx file already installed
#  ansible.builtin.stat:
#    path: "{{ acme_sh_copy_certs_to_path }}/{{ item.domains | first }}"
#  register: pkcs12_file_exists
#  when:
#    - acme_sh_domains and item.domains is defined and item.domains
#    - item.custom_command is undefined or not item.custom_command
#    - item.remove is undefined or not item.remove
#    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
#    - which_openssl_result.rc == 0
#  become_user: "{{ acme_sh_become_user }}"
#
#- name: Create a pkcs12.pfx file
#  ansible.builtin.command: >-
#    {{ which_openssl_result.stdout + " pkcs12 -export" }}
#    -in fullchain.pem
#    -inkey key.pem
#    -out pkcs12.pfx
#    {{ "-passout pass:" + item.acme_sh_pkcs12_password | default(acme_sh_default_pkcs12_password) if item.acme_sh_pkcs12_password | default(acme_sh_default_pkcs12_password) else "" }}
#  loop: "{{ acme_sh_domains }}"
#  args:
#    chdir: "{{ acme_sh_copy_certs_to_path }}/{{ item.domains | first }}"
#  when:
#    - acme_sh_domains and item.domains is defined and item.domains
#    - item.custom_command is undefined or not item.custom_command
#    - item.remove is undefined or not item.remove
#    - not acme_sh_uninstall or acme_sh_uninstall|bool == false
#    - which_openssl_result.rc == 0
#    - pkcs12_file_exists.stat.exists|bool == false
#  become_user: "{{ acme_sh_become_user }}"
#  register: pkcs12_create_result

- name: Register acme.sh certificate information
  command: ./acme.sh --list
  args:
    chdir: "{{ acme_sh_default_directory }}"
  when: acme_sh_list_domains and not acme_sh_uninstall
  changed_when: False
  register: list_domains
  become_user: "{{ acme_sh_become_user }}"

- name: List acme.sh certificate information
  ansible.builtin.debug:
    var: list_domains.stdout_lines
  when: not ansible_check_mode and acme_sh_list_domains and not acme_sh_uninstall
