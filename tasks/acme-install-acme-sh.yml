# acme-install-acme-sh.yml
# ----------------------------------------------------------------------------
# Purpose:
#   Handles installation, configuration, and maintenance of acme.sh from Git.
#   Ensures the local environment has a working copy of acme.sh, properly
#   configured with:
#     • Git clone or update of the acme.sh repository
#     • Installation into the target home directory (usually ~/.acme.sh)
#     • Optional upgrade and CA authority configuration
#     • Optional notification hook setup (email, Slack, etc.)
#     • Creation of the installation and certificate directories
#     • Deployment of systemd service and timer units
#     • Enabling and starting the renewal timer automatically
#
# Notes:
#   - All tasks use become/become_user for safety and privilege consistency.
#   - Safe to re-run; idempotent where possible.
#   - Explicit "Systemd Daemon Reload" step retained for clarity.
#
# Maintainer: KevDog
# Version: 2025.11.07 / compatible with acme.sh ≥ 3.0.8
# Tags: [acme, letsencrypt, automation, setup, systemd, notifications]
# ============================================================================

- name: Get home directory for the become_user
  ansible.builtin.getent:
    database: passwd
    key: "{{ acme_sh_become_user }}"

- name: Resolve acme.sh base directory
  ansible.builtin.set_fact:
    acme_sh_directory_resolved: >-
      {{
        (acme_sh_directory | default(acme_sh_default_directory, true))
        | regex_replace('^~', ansible_facts['getent_passwd'][acme_sh_become_user][4])
      }}
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Resolve acme.sh binary path
  ansible.builtin.set_fact:
    acme_sh_bin_resolved: >-
      {{
        (acme_sh_bin | default(acme_sh_default_bin, true))
        | regex_replace('^~', ansible_facts['getent_passwd'][acme_sh_become_user][4])
      }}
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Check binary existence
- name: Check whether acme.sh binary exists
  ansible.builtin.stat:
    path: "{{ acme_sh_bin }}"
  register: _acme_sh_bin_stat
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Optional PATH fallback
- name: Try to locate acme.sh in PATH when expected path is missing
  ansible.builtin.command: "command -v acme.sh"
  register: _acme_sh_path_lookup
  changed_when: false
  failed_when: false
  when: not _acme_sh_bin_stat.stat.exists
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Adopt PATH acme.sh if found
  ansible.builtin.set_fact:
    acme_sh_bin: "{{ _acme_sh_path_lookup.stdout }}"
  when:
    - not _acme_sh_bin_stat.stat.exists
    - _acme_sh_path_lookup.rc == 0
    - _acme_sh_path_lookup.stdout | length > 0
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Re-check acme.sh binary exists after PATH fallback
  ansible.builtin.stat:
    path: "{{ acme_sh_bin }}"
  register: _acme_sh_bin_stat2
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Install if missing
- name: Install acme.sh from git when missing
  when:
    - not _acme_sh_bin_stat2.stat.exists
    - acme_sh_install_from_git | default(true) | bool
  become: true
  become_user: "{{ acme_sh_become_user }}"
  block:
    - name: Ensure git is installed
      ansible.builtin.package:
        name: git
        state: present

    - name: Ensure acme.sh home directory exists
      ansible.builtin.file:
        path: "{{ acme_sh_directory_resolved }}"
        state: directory
        mode: "0755"

    - name: Clone/update acme.sh repo
      ansible.builtin.git:
        repo: "{{ acme_sh_git_url | default(acme_sh_default_git_url | default('https://github.com/acmesh-official/acme.sh.git')) }}"
        dest: "{{ acme_sh_git_clone_dest | default(acme_sh_default_git_clone_dest | default(acme_sh_directory_resolved ~ '/src')) }}"
        version: "{{ acme_sh_git_version | default(acme_sh_default_git_version | default('master')) }}"
        update: true
        force: "{{ acme_sh_git_clone_force | default(acme_sh_default_git_clone_force | default(false)) | bool }}"

    - name: Run acme.sh installer
      ansible.builtin.command:
        cmd: "./acme.sh --install --accountemail {{ acme_sh_account_email }} --home {{ acme_sh_directory_resolved }} --nocron"
        chdir: "{{ acme_sh_git_clone_dest }}"
        creates: "{{ acme_sh_directory_resolved }}/acme.sh"
      register: _acme_install
      changed_when: _acme_install.rc == 0
      become: true
      become_user: "{{ acme_sh_become_user }}"

    - name: Ensure installed binary executable
      ansible.builtin.file:
        path: "{{ acme_sh_directory_resolved }}/acme.sh"
        state: file
        mode: "0755"
      become: true
      become_user: "{{ acme_sh_become_user }}"

    - name: Repoint acme_sh_bin to installed location
      ansible.builtin.set_fact:
        acme_sh_bin: "{{ acme_sh_directory_resolved }}/acme.sh"

# Final validation
- name: Final check acme.sh exists
  ansible.builtin.stat:
    path: "{{ acme_sh_bin }}"
  register: _acme_sh_bin_final
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Fail if acme.sh is still missing
  ansible.builtin.fail:
    msg: "acme.sh not found at {{ acme_sh_bin }} (home={{ acme_sh_directory_resolved }})"
  when: not _acme_sh_bin_final.stat.exists
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Ensure deploy hook directory exists
- name: Ensure acme.sh deploy hooks directory exists
  ansible.builtin.file:
    path: "{{ acme_sh_directory_resolved }}/deploy"
    state: directory
    mode: "0755"
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Install localcopy deploy hook (script name matters)
- name: Install localcopy deploy hook
  ansible.builtin.template:
    src: acme_deploy_localcopy.sh.j2
    dest: "{{ acme_sh_directory_resolved }}/deploy/localcopy.sh"
    mode: "0755"
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Set auto-upgrade acme.sh
  vars:
    acme_exe: "{{ acme_sh_bin | default(acme_sh_default_bin, true) }}"
  ansible.builtin.shell: >-
    {{
      acme_exe ~ ' --upgrade --auto-upgrade'
    }}
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "{{ bash_executable_path }}"
  when:
    - acme_sh_upgrade | default(acme_sh_default_upgrade | default(true)) | bool
  register: upgrade_result
  changed_when: upgrade_result.rc == 0 and "Upgrade success" in upgrade_result.stdout
  failed_when: upgrade_result.rc != 0
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Use given CA authority - default Let'sEncrypt
  vars:
    acme_exe: "{{ acme_sh_bin | default(acme_sh_default_bin, true) }}"
  ansible.builtin.shell: >-
    {{
      acme_exe ~ ' --set-default-ca --server ' ~
      (acme_sh_server | default(acme_sh_default_server | default('')))
    }}
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "{{ bash_executable_path }}"
  when:
    - not (is_acme_sh_installed.stat.exists | bool)
    - (acme_sh_server | default(acme_sh_default_server | default('letsencrypt'))) | length > 0
  become: true
  become_user: "{{ acme_sh_become_user }}"
  register: acme_default_server_result
  changed_when: acme_default_server_result.rc == 0
  failed_when: acme_default_server_result.rc != 0

- name: Create acme.sh install directory -- Default(/etc/ssl/letsencrypt)
  ansible.builtin.file:
    path: "{{ acme_sh_copy_certs_to_path | default(acme_sh_default_copy_certs_to_path) }}"
    state: directory
    owner: "{{ acme_sh_become_user }}"
    group: "{{ acme_sh_become_user }}"
    mode: "{{ acme_sh_install_directory_permissions | default(acme_sh_default_install_directory_permissions) }}"
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Enable acme.sh notification
  vars:
    acme_exe: "{{ acme_sh_bin | default(acme_sh_default_bin, true) }}"
  ansible.builtin.shell: >-
    {{
      acme_exe ~ ' --set-notify' ~
      ' --notify-level ' ~ (acme_sh_notify_level | default(acme_sh_default_notify_level | default('2'))) ~
      ' --notify-mode ' ~ (acme_sh_notify_mode | default(acme_sh_default_notify_mode | default('0'))) ~
      (acme_sh_notify_hooks | map('regex_replace', '^(.*)$', ' --notify-hook \\1') | join(''))
    }}
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "{{ bash_executable_path }}"
  environment: "{{ acme_sh_notify_env_var }}"
  when:
    - acme_sh_enable_notify
    - acme_sh_notify_hooks | length > 0
    - acme_sh_notify_env_var.keys() | length > 0
  become: true
  become_user: "{{ acme_sh_become_user }}"
  register: acme_notify_result
  changed_when: acme_notify_result.rc == 0
  failed_when: acme_notify_result.rc != 0

- name: Install {{ systemd_service_name }}.service
  ansible.builtin.template:
    src: acme_letsencrypt.service.j2
    dest: "{{ acme_sh_systemd_service_path | default(acme_sh_default_systemd_service_path) }}"
    force: true
    owner: root
    group: root
    mode: '0644'
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Install {{ systemd_timer_name }}.timer
  ansible.builtin.template:
    src: acme_letsencrypt.timer.j2
    dest: "{{ acme_sh_systemd_timer_path | default(acme_sh_default_systemd_timer_path) }}"
    force: true
    owner: root
    group: root
    mode: '0644'
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Systemd Daemon Reload
  ansible.builtin.systemd_service:
    daemon_reload: true
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Determine if systemd timer file exists
  ansible.builtin.stat:
    path: "{{ acme_sh_systemd_timer_path | default(acme_sh_default_systemd_timer_path) }}"
  register: systemd_timer_file_exists_result
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Determine if systemd service file exists
  ansible.builtin.stat:
    path: "{{ acme_sh_systemd_service_path | default(acme_sh_default_systemd_service_path) }}"
  register: systemd_service_file_exists_result
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Enable and start acme.sh systemd timer for renewals
  ansible.builtin.systemd_service:
    name: "{{ acme_sh_systemd_timer_name }}"
    enabled: true
    state: started
    daemon_reload: true
  when:
    - systemd_timer_file_exists_result.stat.exists
    - systemd_service_file_exists_result.stat.exists
  become: true
  become_user: "{{ acme_sh_become_user }}"

