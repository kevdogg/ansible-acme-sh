# acme-install-acme-sh.yml
# ----------------------------------------------------------------------------
# Purpose:
#   Handles installation, configuration, and maintenance of acme.sh from Git.
#   Ensures the local environment has a working copy of acme.sh, properly
#   configured with:
#     • Git clone or update of the acme.sh repository
#     • Installation into the target home directory (usually ~/.acme.sh)
#     • Optional upgrade and CA authority configuration
#     • Optional notification hook setup (email, Slack, etc.)
#     • Creation of the installation and certificate directories
#     • Deployment of systemd service and timer units
#     • Enabling and starting the renewal timer automatically
#
# Notes:
#   - All tasks use become/become_user for safety and privilege consistency.
#   - Safe to re-run; idempotent where possible.
#   - Explicit "Systemd Daemon Reload" step retained for clarity.
#
# Maintainer: KevDog
# Version: 2025.11.07 / compatible with acme.sh ≥ 3.0.8
# Tags: [acme, letsencrypt, automation, setup, systemd, notifications]
# ============================================================================

- name: Resolve acme.sh paths
  ansible.builtin.include_tasks:
    file: acme-resolve-paths.yml
    apply:
      tags: [always]
  tags: [always]

# Check binary existence
- name: Check whether acme.sh binary exists
  ansible.builtin.stat:
    path: "{{ acme_sh_bin }}"
  register: _acme_sh_bin_stat
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Optional PATH fallback
- name: Try to locate acme.sh in PATH when expected path is missing
  ansible.builtin.command: "command -v acme.sh"
  register: _acme_sh_path_lookup
  changed_when: false
  failed_when: false
  when: not _acme_sh_bin_stat.stat.exists
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Adopt PATH acme.sh if found
  ansible.builtin.set_fact:
    acme_sh_bin: "{{ _acme_sh_path_lookup.stdout }}"
  when:
    - not _acme_sh_bin_stat.stat.exists
    - _acme_sh_path_lookup.rc == 0
    - _acme_sh_path_lookup.stdout | length > 0
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Re-check acme.sh binary exists after PATH fallback
  ansible.builtin.stat:
    path: "{{ acme_sh_bin }}"
  register: _acme_sh_bin_stat2
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Install if missing
- name: Install acme.sh from git when missing
  when:
    - not _acme_sh_bin_stat2.stat.exists
    - acme_sh_install_from_git | default(true) | bool
  become: true
  become_user: "{{ acme_sh_become_user }}"
  block:
    - name: Ensure git is installed
      ansible.builtin.package:
        name: git
        state: present

    - name: Ensure acme.sh home directory exists
      ansible.builtin.file:
        path: "{{ acme_sh_directory_resolved }}"
        state: directory
        mode: "0755"

    - name: Clone/update acme.sh repo
      ansible.builtin.git:
        repo: "{{ acme_sh_git_url | default(acme_sh_default_git_url | default('https://github.com/acmesh-official/acme.sh.git')) }}"
        dest: "{{ acme_sh_git_clone_dest | default(acme_sh_default_git_clone_dest | default(acme_sh_directory_resolved ~ '/src')) }}"
        version: "{{ acme_sh_git_version | default(acme_sh_default_git_version | default('master')) }}"
        update: true
        force: "{{ acme_sh_git_clone_force | default(acme_sh_default_git_clone_force | default(false)) | bool }}"

    - name: Run acme.sh installer
      ansible.builtin.command:
        cmd: "./acme.sh --install --accountemail {{ acme_sh_account_email }} --home {{ acme_sh_directory_resolved }} --nocron"
        chdir: "{{ acme_sh_git_clone_dest }}"
        creates: "{{ acme_sh_directory_resolved }}/acme.sh"
      register: _acme_install
      changed_when: _acme_install.rc == 0
      become: true
      become_user: "{{ acme_sh_become_user }}"

    - name: Ensure installed binary executable
      ansible.builtin.file:
        path: "{{ acme_sh_directory_resolved }}/acme.sh"
        state: file
        mode: "0755"
      become: true
      become_user: "{{ acme_sh_become_user }}"

    - name: Repoint acme_sh_bin to installed location
      ansible.builtin.set_fact:
        acme_sh_bin: "{{ acme_sh_directory_resolved }}/acme.sh"

# Final validation
- name: Final check acme.sh exists
  ansible.builtin.stat:
    path: "{{ acme_sh_bin }}"
  register: _acme_sh_bin_final
  changed_when: false
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Fail if acme.sh is still missing
  ansible.builtin.fail:
    msg: "acme.sh not found at {{ acme_sh_bin }} (home={{ acme_sh_directory_resolved }})"
  when: not _acme_sh_bin_final.stat.exists
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Ensure deploy hook directory exists
- name: Ensure acme.sh deploy hooks directory exists
  ansible.builtin.file:
    path: "{{ acme_sh_directory_resolved }}/deploy"
    state: directory
    mode: "0755"
  become: true
  become_user: "{{ acme_sh_become_user }}"

# Check if localcopy deploy hook exists within {{ acme_sh_directory_resolved/deploy }} as localcopy is currently missing from git repository
- name: Check for existence of deploy hook localcopy
  ansible.builtin.stat:
    path: "{{ acme_sh_directory_resolved }}/deploy/{{ acme_sh_deploy_hook_localcopy | default(acme_sh_default_deploy_hook_localcopy, true) }}"
  register: _localcopy_deploy_hook
  become: true
  become_user: "{{ acme_sh_become_user }}"
  when:
    - _acme_sh_bin_final.stat.exists

# Install localcopy deploy hook (script name matters)
- name: Install localcopy deploy hook
  ansible.builtin.template:
    src: acme_deploy_localcopy.sh.j2
    dest: "{{ acme_sh_directory_resolved }}/deploy/localcopy.sh"
    mode: "0755"
  become: true
  become_user: "{{ acme_sh_become_user }}"
  when:
    - not _localcopy_deploy_hook.stat.exists

- name: Read acme.sh account configuration for CA check
  ansible.builtin.slurp:
    src: "{{ acme_sh_directory_resolved }}/account.conf"
  register: _acme_account_conf
  become: true
  become_user: "{{ acme_sh_become_user }}"
  # We use failed_when: false because if it's a brand new install, 
  # account.conf might not even exist yet.
  failed_when: false

- name: Set auto-upgrade acme.sh
  vars:
    acme_exe: "{{ acme_sh_bin }}"
    # Resolve the boolean once
    should_upgrade: "{{ acme_sh_upgrade | default(acme_sh_default_upgrade | default(true)) | bool }}"
  ansible.builtin.shell: >-
    {{ acme_exe }} --upgrade --auto-upgrade
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "/bin/bash"
  become: true
  become_user: "{{ acme_sh_become_user }}"
  register: upgrade_result
  when:
    # 1. Only if the binary exists
    - _acme_sh_bin_final.stat.exists
    # 2. Only if the user actually wants auto-upgrade enabled
    - should_upgrade
    # 3.ROBUST CHECK: Skip if the variable name even exists in the file
    - >
      _acme_account_conf.content is not defined or
      "AUTO_UPGRADE=" not in (_acme_account_conf.content | b64decode)
  changed_when: "'Success' in upgrade_result.stdout"

- name: Use given CA authority - default Let'sEncrypt
  vars:
    acme_exe: "{{ acme_sh_bin }}"
    target_ca: "{{ acme_sh_server | default(acme_sh_default_server | default('letsencrypt'), true) }}"
  ansible.builtin.shell: >-
    {{ acme_exe }} --set-default-ca --server {{ target_ca }}
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "{{ acme_sh_executable_path | default(acme_sh_default_executable_path | default('/bin/bash'), true) }}"
  become: true
  become_user: "{{ acme_sh_become_user }}"
  register: _acme_ca_result
  when:
    - _acme_sh_bin_final.stat.exists
    - target_ca | length > 0
    # Search the decoded config for the DEFAULT_CA line and see if our target is in it
    - >
      _acme_account_conf.content is not defined or 
      target_ca not in (_acme_account_conf.content | b64decode | regex_findall('DEFAULT_CA=.*') | first | default(''))
  changed_when: "'Success' in _acme_ca_result.stdout"

- name: Create acme.sh install directory -- Default(/etc/ssl/letsencrypt)
  ansible.builtin.file:
    path: "{{ acme_sh_copy_certs_to_path | default(acme_sh_default_copy_certs_to_path) }}"
    state: directory
    owner: "{{ acme_sh_become_user }}"
    group: "{{ acme_sh_become_user }}"
    mode: "{{ acme_sh_install_directory_permissions | default(acme_sh_default_install_directory_permissions) }}"
  become: true
  become_user: "{{ acme_sh_become_user }}"

- name: Configure acme.sh notifications
  vars:
    acme_exe: "{{ acme_sh_bin }}"
    hooks_string: "{{ acme_sh_notify_hooks | map('regex_replace', '^(.*)$', ' --notify-hook \\1') | join('') }}"
  ansible.builtin.shell: >-
    {{ acme_exe }} 
    --set-notify 
    --notify-level {{ acme_sh_notify_level | default('2') }}
    --notify-mode {{ acme_sh_notify_mode | default('0') }}
    {{ hooks_string }}
  args:
    chdir: "{{ acme_sh_directory_resolved }}"
    executable: "/bin/bash"
  environment: "{{ acme_sh_notify_env_var }}"
  become: true
  become_user: "{{ acme_sh_become_user }}"
  # ROBUST CHECK: Run if file is missing OR if any hook is not yet configured
  when:
    - acme_sh_enable_notify | bool
    - (_acme_account_conf.content is not defined) or
      (acme_sh_notify_hooks | reject('in', (_acme_account_conf.content | default('') | b64decode)) | list | length > 0) | bool
  register: _notify_result
  changed_when: "'Success' in _notify_result.stdout"

#- name: Enable acme.sh notification
#  vars:
#    acme_exe: "{{ acme_sh_bin | default(acme_sh_default_bin, true) }}"
#  ansible.builtin.shell: >-
#    {{
#      acme_exe ~ ' --set-notify' ~
#      ' --notify-level ' ~ (acme_sh_notify_level | default(acme_sh_default_notify_level | default('2'))) ~
#      ' --notify-mode ' ~ (acme_sh_notify_mode | default(acme_sh_default_notify_mode | default('0'))) ~
#      (acme_sh_notify_hooks | map('regex_replace', '^(.*)$', ' --notify-hook \\1') | join(''))
#    }}
#  args:
#    chdir: "{{ acme_sh_directory_resolved }}"
#    executable: "{{ bash_executable_path }}"
#  environment: "{{ acme_sh_notify_env_var }}"
#  when:
#    - acme_sh_enable_notify
#    - acme_sh_notify_hooks | length > 0
#    - acme_sh_notify_env_var.keys() | length > 0
#  become: true
#  become_user: "{{ acme_sh_become_user }}"
#  register: acme_notify_result
#  changed_when: acme_notify_result.rc == 0
#  failed_when: acme_notify_result.rc != 0

- name: "Install {{ acme_sh_systemd_service_name | default(acme_sh_default_systemd_service_name, true) }}"
  ansible.builtin.template:
    src: acme_letsencrypt.service.j2
    dest: "{{ acme_sh_systemd_service_path | default(acme_sh_default_systemd_service_path, true) }}"
    force: true
    owner: root
    group: root
    mode: '0644'
  become: true

- name: "Install {{ acme_sh_systemd_timer_name | default(acme_sh_default_systemd_timer_name, true) }}"
  ansible.builtin.template:
    src: acme_letsencrypt.timer.j2
    dest: "{{ acme_sh_systemd_timer_path | default(acme_sh_default_systemd_timer_path, true) }}"
    force: true
    owner: root
    group: root
    mode: '0644'
  become: true

- name: Systemd Daemon Reload
  ansible.builtin.systemd_service:
    daemon_reload: true
  become: true

- name: Determine if systemd timer file exists
  ansible.builtin.stat:
    path: "{{ acme_sh_systemd_timer_path | default(acme_sh_default_systemd_timer_path) }}"
  register: systemd_timer_file_exists_result
  become: true

- name: Determine if systemd service file exists
  ansible.builtin.stat:
    path: "{{ acme_sh_systemd_service_path | default(acme_sh_default_systemd_service_path) }}"
  register: systemd_service_file_exists_result
  become: true

- name: Enable and start acme.sh systemd timer for renewals
  ansible.builtin.systemd_service:
    name: "{{ acme_sh_systemd_timer_name | default(acme_sh_default_systemd_timer_name, true) }}"
    enabled: true
    state: started
    daemon_reload: true
  when:
    - systemd_timer_file_exists_result.stat.exists
    - systemd_service_file_exists_result.stat.exists
  become: true

